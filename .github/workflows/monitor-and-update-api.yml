name: Monitor and Update Proto API

on:
  schedule:
    # Run every 3 hours in PST (UTC-8) starting at 9 AM PST
    # This translates to 5pm, 8pm, 11pm, 2am, 5am, 8am, 11am, 2pm UTC
    - cron: '0 17,20,23,2,5,8,11,14 * * *'
  workflow_dispatch:  # Allow manual trigger

jobs:
  check-and-update:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout proto-api-docs
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PRIVATE_REPO_TOKEN }}
          fetch-depth: 0
      
      - name: Fetch upstream API spec from multiple possible locations
        id: fetch
        env:
          GITHUB_TOKEN: ${{ secrets.PRIVATE_REPO_TOKEN }}
        run: |
          echo "üì• Attempting to fetch latest API spec from miner-firmware..."
          
          # Define potential locations to check
          LOCATIONS=(
            "main/crates/miner-api-server/docs/MDK-API.json"
            "master/crates/miner-api-server/docs/MDK-API.json"
            "develop/crates/miner-api-server/docs/MDK-API.json"
            "main/crates/miner-api-server/docs/MDK-API.json.v1.7.7"
            "main/crates/miner-api-server/MDK-API.json"
            "main/docs/MDK-API.json"
          )
          
          FOUND=false
          
          for LOCATION in "${LOCATIONS[@]}"; do
            echo "Trying: https://raw.githubusercontent.com/btc-mining/miner-firmware/${LOCATION}"
            
            # Download from the current location
            curl -s -H "Authorization: token $GITHUB_TOKEN" \
              "https://raw.githubusercontent.com/btc-mining/miner-firmware/${LOCATION}" \
              -o /tmp/upstream-spec.json
            
            # Check if we got a valid JSON file with a version field
            if jq -e '.info.version' /tmp/upstream-spec.json > /dev/null 2>&1; then
              FOUND=true
              FOUND_LOCATION="${LOCATION}"
              echo "‚úÖ Found valid API spec at: ${LOCATION}"
              echo "found_location=${LOCATION}" >> $GITHUB_OUTPUT
              break
            else
              echo "‚ùå No valid API spec at: ${LOCATION}"
            fi
          done
          
          if [ "$FOUND" = false ]; then
            echo "‚ùå Could not find valid API spec in any of the checked locations"
            exit 1
          fi
          
          # Validate it's valid JSON
          if ! jq empty /tmp/upstream-spec.json 2>/dev/null; then
            echo "‚ùå Invalid JSON from upstream"
            exit 1
          fi
          
          echo "‚úÖ Fetched upstream spec successfully from ${FOUND_LOCATION}"
      
      - name: Normalize text in API spec
        id: normalize
        run: |
          echo "üîß Normalizing text in API spec..."
          
          # Create a backup of the raw upstream spec
          cp /tmp/upstream-spec.json /tmp/upstream-spec-raw.json
          
          # Apply text normalizations (idempotent)
          # These fix common malformed text patterns from code generation
          cat /tmp/upstream-spec.json | \
            sed 's/Ps Us/PSUs/g' | \
            sed 's/PsUs/PSUs/g' | \
            sed 's/Psus/PSUs/g' | \
            sed 's/\([^A-Z]\)Api\([^a-z]\)/\1API\2/g' | \
            sed 's/\([^A-Z]\)Api$/\1API/g' | \
            sed 's/^Api\([^a-z]\)/API\1/g' | \
            sed 's/ api / API /g' | \
            sed 's/^api /API /g' | \
            sed 's/ api$/ API/g' | \
            sed 's/Psu\([^a-z]\)/PSU\1/g' | \
            sed 's/Psu$/PSU/g' | \
            sed -E 's/(^|[^a-zA-Z])psu([^a-zA-Z]|$)/\1PSU\2/g' | \
            sed -E 's/(^|[^a-zA-Z])psus([^a-zA-Z]|$)/\1PSUs\2/g' > /tmp/upstream-spec-normalized.json
          
          # Validate normalized JSON is still valid
          if ! jq empty /tmp/upstream-spec-normalized.json 2>/dev/null; then
            echo "‚ùå Normalization broke JSON structure"
            exit 1
          fi
          
          # Count what was normalized
          NORMALIZATION_COUNT=0
          NORMALIZATION_DETAILS=""
          
          # Check for specific normalizations
          PSU_FIXES=$(diff -u /tmp/upstream-spec-raw.json /tmp/upstream-spec-normalized.json | grep -c "Ps Us\|PsUs" || echo "0")
          API_FIXES=$(diff -u /tmp/upstream-spec-raw.json /tmp/upstream-spec-normalized.json | grep -c "Api" || echo "0")
          
          if [ "$PSU_FIXES" -gt 0 ]; then
            NORMALIZATION_DETAILS="${NORMALIZATION_DETAILS}‚Ä¢ Fixed PSU capitalization (${PSU_FIXES} changes)\n"
            NORMALIZATION_COUNT=$((NORMALIZATION_COUNT + PSU_FIXES))
          fi
          
          if [ "$API_FIXES" -gt 0 ]; then
            NORMALIZATION_DETAILS="${NORMALIZATION_DETAILS}‚Ä¢ Fixed API capitalization (${API_FIXES} changes)\n"
            NORMALIZATION_COUNT=$((NORMALIZATION_COUNT + API_FIXES))
          fi
          
          # Save normalization report
          if [ "$NORMALIZATION_COUNT" -gt 0 ]; then
            echo "normalization_applied=true" >> $GITHUB_OUTPUT
            {
              echo "normalization_report<<EOF_NORM"
              echo -e "$NORMALIZATION_DETAILS"
              echo "EOF_NORM"
            } >> $GITHUB_OUTPUT
            echo "‚úÖ Applied $NORMALIZATION_COUNT text normalizations"
            echo -e "$NORMALIZATION_DETAILS"
          else
            echo "normalization_applied=false" >> $GITHUB_OUTPUT
            echo "normalization_report=No text normalizations needed" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  No text normalizations needed"
          fi
          
          # Use normalized version for comparison
          mv /tmp/upstream-spec-normalized.json /tmp/upstream-spec.json
      
      - name: Setup Node.js for linting
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Validate OpenAPI spec with Redocly
        id: lint
        continue-on-error: true
        run: |
          echo "üîç Validating OpenAPI spec with Redocly..."
          
          # Install Redocly CLI
          npm install -g @redocly/cli
          
          # Run linting (skip operation-description rule, don't fail workflow)
          if redocly lint /tmp/upstream-spec.json --skip-rule operation-description 2>&1 | tee /tmp/lint-output.txt; then
            echo "lint_status=‚úÖ Passed" >> $GITHUB_OUTPUT
            echo "‚úÖ OpenAPI spec validation passed"
          else
            # Extract issues but don't fail
            LINT_ISSUES=$(cat /tmp/lint-output.txt | grep -E "error|warning" | head -10 || echo "See full output in logs")
            echo "lint_status=‚ö†Ô∏è  Issues found (non-blocking)" >> $GITHUB_OUTPUT
            {
              echo "lint_issues<<EOF_LINT"
              echo "$LINT_ISSUES"
              echo "EOF_LINT"
            } >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Validation found issues (non-blocking):"
            echo "$LINT_ISSUES"
          fi
      
      - name: Compare versions
        id: compare
        run: |
          echo "üìä Comparing versions..."
          
          # Extract versions from normalized spec
          UPSTREAM_VERSION=$(jq -r '.info.version' /tmp/upstream-spec.json)
          CURRENT_VERSION=$(jq -r '.info.version' spec.json)
          
          # Trim any whitespace that might be present
          UPSTREAM_VERSION=$(echo "$UPSTREAM_VERSION" | xargs)
          CURRENT_VERSION=$(echo "$CURRENT_VERSION" | xargs)
          
          echo "upstream_version=$UPSTREAM_VERSION" >> $GITHUB_OUTPUT
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          
          echo "üìä Current version: $CURRENT_VERSION"
          echo "üìä Upstream version: $UPSTREAM_VERSION"
          
          # Check if version changed
          if [ "$UPSTREAM_VERSION" != "$CURRENT_VERSION" ]; then
            echo "version_changed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Version changed: $CURRENT_VERSION ‚Üí $UPSTREAM_VERSION"
            
            # Log detailed version information for debugging
            echo "Upstream version (hex): $(echo -n "$UPSTREAM_VERSION" | xxd -p)"
            echo "Current version (hex): $(echo -n "$CURRENT_VERSION" | xxd -p)"
            echo "Upstream version length: ${#UPSTREAM_VERSION}"
            echo "Current version length: ${#CURRENT_VERSION}"
          else
            echo "version_changed=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  No version change detected"
          fi
      
      - name: Notify version change detected
        if: steps.compare.outputs.version_changed == 'true'
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          CURRENT_VERSION="${{ steps.compare.outputs.current_version }}"
          UPSTREAM_VERSION="${{ steps.compare.outputs.upstream_version }}"
          FOUND_LOCATION="${{ steps.fetch.outputs.found_location }}"
          
          curl -X POST "$SLACK_WEBHOOK" \
            -H 'Content-Type: application/json' \
            -d @- << EOF
          {
            "blocks": [
              {
                "type": "header",
                "text": {
                  "type": "plain_text",
                  "text": "üîî New Proto API Version Detected!",
                  "emoji": true
                }
              },
              {
                "type": "section",
                "fields": [
                  {
                    "type": "mrkdwn",
                    "text": "*Current Version:*\n$CURRENT_VERSION"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*New Version:*\n$UPSTREAM_VERSION"
                  }
                ]
              },
              {
                "type": "section",
                "fields": [
                  {
                    "type": "mrkdwn",
                    "text": "*Source Location:*\n\`$FOUND_LOCATION\`"
                  }
                ]
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "ü§ñ Starting automatic documentation update..."
                }
              },
              {
                "type": "actions",
                "elements": [
                  {
                    "type": "button",
                    "text": {
                      "type": "plain_text",
                      "text": "üìñ View API Docs",
                      "emoji": true
                    },
                    "url": "https://proto-sdk.github.io/proto-api-docs/",
                    "style": "primary"
                  }
                ]
              }
            ]
          }
          EOF
      
      - name: Analyze API changes
        if: steps.compare.outputs.version_changed == 'true'
        id: analyze
        run: |
          echo "üîç Analyzing changes between versions..."
          
          # Compare the two spec files to find actual changes in descriptions
          HASHRATE_CHANGES=$(diff -u <(jq -r '.. | select(type == "string") | select(contains("hash rate"))' spec.json 2>/dev/null || echo "") \
                                      <(jq -r '.. | select(type == "string") | select(contains("hash rate"))' /tmp/upstream-spec.json 2>/dev/null || echo "") | grep -c "^-" || echo "0")
          
          HASHBOARD_CHANGES=$(diff -u <(jq -r '.. | select(type == "string") | select(contains("hash board"))' spec.json 2>/dev/null || echo "") \
                                       <(jq -r '.. | select(type == "string") | select(contains("hash board"))' /tmp/upstream-spec.json 2>/dev/null || echo "") | grep -c "^-" || echo "0")
          
          # Compare endpoints
          OLD_ENDPOINTS=$(jq -r '.paths | keys | length' spec.json)
          NEW_ENDPOINTS=$(jq -r '.paths | keys | length' /tmp/upstream-spec.json)
          ENDPOINT_DIFF=$((NEW_ENDPOINTS - OLD_ENDPOINTS))
          
          # Compare tags
          OLD_TAGS=$(jq -r '.tags | length' spec.json 2>/dev/null || echo "0")
          NEW_TAGS=$(jq -r '.tags | length' /tmp/upstream-spec.json 2>/dev/null || echo "0")
          TAG_DIFF=$((NEW_TAGS - OLD_TAGS))
          
          # Create detailed change summary
          CHANGE_SUMMARY="‚Ä¢ Updated API specification from miner-firmware upstream"
          
          if [ "$ENDPOINT_DIFF" -gt 0 ]; then
            CHANGE_SUMMARY="$CHANGE_SUMMARY\n‚Ä¢ Added $ENDPOINT_DIFF new endpoints"
          elif [ "$ENDPOINT_DIFF" -lt 0 ]; then
            CHANGE_SUMMARY="$CHANGE_SUMMARY\n‚Ä¢ Removed $((-ENDPOINT_DIFF)) endpoints"
          fi
          
          if [ "$TAG_DIFF" -gt 0 ]; then
            CHANGE_SUMMARY="$CHANGE_SUMMARY\n‚Ä¢ Added $TAG_DIFF new tags"
          elif [ "$TAG_DIFF" -lt 0 ]; then
            CHANGE_SUMMARY="$CHANGE_SUMMARY\n‚Ä¢ Removed $((-TAG_DIFF)) tags"
          fi
          
          if [ "$HASHRATE_CHANGES" -gt 0 ] || [ "$HASHBOARD_CHANGES" -gt 0 ]; then
            CHANGE_SUMMARY="$CHANGE_SUMMARY\n‚Ä¢ Fixed inconsistent spacing in compound words"
            if [ "$HASHRATE_CHANGES" -gt 0 ]; then
              CHANGE_SUMMARY="$CHANGE_SUMMARY\n‚Ä¢ Changed \"hash rate\" ‚Üí \"hashrate\" ($HASHRATE_CHANGES occurrences)"
            fi
            if [ "$HASHBOARD_CHANGES" -gt 0 ]; then
              CHANGE_SUMMARY="$CHANGE_SUMMARY\n‚Ä¢ Changed \"hash board\" ‚Üí \"hashboard\" ($HASHBOARD_CHANGES occurrences)"
            fi
            CHANGE_SUMMARY="$CHANGE_SUMMARY\n‚Ä¢ Improved documentation consistency"
          fi
          
          # Save to output
          {
            echo "changes<<EOF_CHANGES"
            echo -e "$CHANGE_SUMMARY"
            echo "EOF_CHANGES"
          } >> $GITHUB_OUTPUT
          
          echo "‚úÖ Changes analyzed"
          echo -e "Summary:\n$CHANGE_SUMMARY"
      
      - name: Update API specification
        if: steps.compare.outputs.version_changed == 'true'
        run: |
          echo "üìù Updating spec.json..."
          
          # Backup current spec
          cp spec.json spec.json.backup.$(date +%Y%m%d_%H%M%S)
          
          # Update the spec - rename title to match our branding
          jq '.info.title = "Proto Mining API"' /tmp/upstream-spec.json > spec.json
          
          echo "‚úÖ spec.json updated"
      
      - name: Update CHANGELOG
        if: steps.compare.outputs.version_changed == 'true'
        run: |
          echo "üìù Updating CHANGELOG.md..."
          
          UPSTREAM_VERSION="${{ steps.compare.outputs.upstream_version }}"
          CURRENT_VERSION="${{ steps.compare.outputs.current_version }}"
          DATE=$(date +%Y-%m-%d)
          FOUND_LOCATION="${{ steps.fetch.outputs.found_location }}"
          
          # Get the analyzed changes
          CHANGES=$(cat << 'CHANGES_EOF'
          ${{ steps.analyze.outputs.changes }}
          CHANGES_EOF
          )
          
          # Get normalization report
          NORM_REPORT=$(cat << 'NORM_EOF'
          ${{ steps.normalize.outputs.normalization_report }}
          NORM_EOF
          )
          
          # Create changelog entry with detailed changes
          cat > /tmp/changelog_entry.md << EOF
          ## [$UPSTREAM_VERSION] - $DATE

          ### Changed
          $CHANGES
          - Version bump: $CURRENT_VERSION ‚Üí $UPSTREAM_VERSION
          - Automatically synchronized with btc-mining/miner-firmware
          - Source: $FOUND_LOCATION

          ### Text Normalizations Applied
          $NORM_REPORT

          EOF
          
          # Prepend to CHANGELOG (after the title)
          if [ -f CHANGELOG.md ]; then
            # Insert after the first line (title)
            sed -i '1 r /tmp/changelog_entry.md' CHANGELOG.md
          else
            # Create new changelog
            echo "# Changelog" > CHANGELOG.md
            cat /tmp/changelog_entry.md >> CHANGELOG.md
          fi
          
          echo "‚úÖ CHANGELOG.md updated"
      
      - name: Commit and push changes
        if: steps.compare.outputs.version_changed == 'true'
        run: |
          git config user.name "Proto API Bot"
          git config user.email "mining@block.xyz"
          
          git add spec.json CHANGELOG.md spec.json.backup.*
          git commit -m "ü§ñ Auto-update: Proto API v${{ steps.compare.outputs.upstream_version }}

          - Updated from miner-firmware upstream
          - Source: ${{ steps.fetch.outputs.found_location }}
          - Previous version: ${{ steps.compare.outputs.current_version }}
          - New version: ${{ steps.compare.outputs.upstream_version }}
          - Auto-generated by monitor-and-update-api workflow"
          
          git push
          
          echo "‚úÖ Changes pushed to main branch"
      
      - name: Wait for GitHub Pages deployment
        if: steps.compare.outputs.version_changed == 'true'
        run: |
          echo "‚è≥ Waiting 60 seconds for GitHub Pages to deploy..."
          sleep 60
      
      - name: Send notifications to Slack
        if: steps.compare.outputs.version_changed == 'true'
        env:
          SLACK_WEBHOOK_DOCS: ${{ secrets.SLACK_WEBHOOK_DOCS_CHANNEL }}
          SLACK_WEBHOOK_HMOSES: ${{ secrets.SLACK_WEBHOOK_HMOSES }}
        run: |
          UPSTREAM_VERSION="${{ steps.compare.outputs.upstream_version }}"
          CURRENT_VERSION="${{ steps.compare.outputs.current_version }}"
          COMMIT_SHA=$(git rev-parse HEAD)
          COMMIT_SHA_SHORT=$(git rev-parse --short HEAD)
          FOUND_LOCATION="${{ steps.fetch.outputs.found_location }}"
          
          # Get the analyzed changes
          CHANGES=$(cat << 'CHANGES_EOF'
          ${{ steps.analyze.outputs.changes }}
          CHANGES_EOF
          )
          
          # Get normalization report
          NORM_REPORT=$(cat << 'NORM_EOF'
          ${{ steps.normalize.outputs.normalization_report }}
          NORM_EOF
          )
          
          # Get lint status
          LINT_STATUS="${{ steps.lint.outputs.lint_status }}"
          
          # Build the Slack message with detailed changes
          SLACK_MESSAGE=$(jq -n \
            --arg current "$CURRENT_VERSION" \
            --arg upstream "$UPSTREAM_VERSION" \
            --arg commit "$COMMIT_SHA" \
            --arg commit_short "$COMMIT_SHA_SHORT" \
            --arg changes "$CHANGES" \
            --arg normalization "$NORM_REPORT" \
            --arg lint "$LINT_STATUS" \
            --arg location "$FOUND_LOCATION" \
            '{
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "‚úÖ Proto API Documentation Updated!",
                    "emoji": true
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Version:*\n\($current) ‚Üí \($upstream)"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Status:*\n‚úÖ Live"
                    }
                  ]
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Source:*\n`\($location)`"
                    }
                  ]
                },
                {
                  "type": "divider"
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*‚ú® What's New*\n\($changes)"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*üîß Text Normalizations:*\n\($normalization)"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*üîç OpenAPI Validation:*\n\($lint)"
                  }
                },
                {
                  "type": "divider"
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "üìñ View Production Docs",
                        "emoji": true
                      },
                      "url": "https://proto-sdk.github.io/proto-api-docs/",
                      "style": "primary"
                    },
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "üîç View Commit",
                        "emoji": true
                      },
                      "url": "https://github.com/proto-sdk/proto-api-docs/commit/\($commit)"
                    },
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "üìù View Changelog",
                        "emoji": true
                      },
                      "url": "https://github.com/proto-sdk/proto-api-docs/blob/main/CHANGELOG.md"
                    }
                  ]
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "ü§ñ Automatically updated by Proto API Monitor | Commit: `\($commit_short)`"
                    }
                  ]
                }
              ]
            }')
          
          # Send to #proto-documentation
          echo "$SLACK_MESSAGE" | curl -X POST "$SLACK_WEBHOOK_DOCS" \
            -H 'Content-Type: application/json' \
            -d @-
          
          echo "‚úÖ Notification sent to #proto-documentation"
          
          # Send to #hmoses
          echo "$SLACK_MESSAGE" | curl -X POST "$SLACK_WEBHOOK_HMOSES" \
            -H 'Content-Type: application/json' \
            -d @-
          
          echo "‚úÖ Notification sent to #hmoses"

      - name: Notify MCP servers
        if: steps.compare.outputs.version_changed == 'true'
        run: |
          echo "üì° Notifying MCP servers of API update..."
          
          # Run the MCP notification script
          bash .github/scripts/notify-mcp-update.sh \
            "${{ steps.compare.outputs.upstream_version }}" \
            "${{ steps.analyze.outputs.changes_summary }}"
          
          echo "‚úÖ MCP servers notified"

      
      - name: No changes detected
        if: steps.compare.outputs.version_changed == 'false'
        run: |
          echo "‚ÑπÔ∏è  No version changes detected. Documentation is up to date."
          echo "Current version: ${{ steps.compare.outputs.current_version }}"
